<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>


<title>Help page for Minimal-MUMCUT Coverage web app</title>
<meta http-equiv="Content-Type" content="text/html">
<meta content="Nan Li" name="author">
 <style>
  P{text-align:justify}
  P.menu{font-size:75%;color:#555555;background-color:E4F4E4}
  A:hover {background:white}
 </style>
</head>

<body bgcolor="#ddeedd">
<p style="text-align:center;font-size:150%;font-weight:bold">Help Page for the Minimal MUMCUT Coverage Web Application</p>

<p>
This tool produces test set specifications to satisfy DNF coverage logic criteria.
Predicates must be in <i>minimal DNF</i> form.
Users enter a predicate and choose a criterion,
and the tool generates non-equivalent mutants that can only be killed
by a test set that satisfies that criterion.
</p>

<p>
A minimal-DNF predicate consists of literals connected by <b>AND</b>
and terms separated by <b>OR</b>,
where all terms are <i>prime implicants</i>.
A <a href="http://en.wikipedia.org/wiki/Implicant" target=_blank>prime implicant</a>

of a function is an implicant that cannot be covered by a more general
(more reduced&mdash;meaning with fewer literals) implicant. 
A test set that satisfies the Minimal-MUMCUT criterion is guaranteed to detect
the following nine single faults:
</p>

<ol> <!-- to indent a bit -->
<table border=1 bgcolor="#EEFFEE">
  <tr><td>1.<td>Expression Negation Fault  <td>(<i>ENF</i>)  <td>Implementing <i>ab + cd</i> as <i>!(ab + cd)</i></tr>

  <tr><td>2.<td>Term Negation Fault        <td>(<i>TNF</i>)  <td>Implementing <i>ab + cd</i> as <i>!(ab) + cd</i></tr>
  <tr><td>3.<td>Term Omission Fault        <td>(<i>TOF</i>)  <td>Implementing <i>ab + cd</i> as <i>cd</i></tr>

  <tr><td>4.<td>Literal Reference Fault    <td>(<i>LRF</i>)  <td>Implementing <i>ab + cd</i> as <i>cb + cd</i></tr>
  <tr><td>5.<td>Literal Insertion Fault    <td>(<i>LIF</i>)  <td>Implementing <i>ab + cd</i> as <i>abc + cd</i></tr>

  <tr><td>6.<td>Literal Omission Fault     <td>(<i>LOF</i>)  <td>Implementing <i>ab + cd</i> as <i>b + cd</i></tr>
  <tr><td>7.<td>Literal Negation Fault     <td>(<i>LNF</i>)  <td>Implementing <i>ab + cd</i> as <i>!(a)b + cd</i></tr>

  <tr><td>8.<td>Operator Reference Fault + <td>(<i>ORF+</i>) <td>Implementing <i>ab + cd</i> as <i>abcd</i></tr>
  <tr><td>9.<td>Operator Reference Fault . <td>(<i>ORF.</i>) <td>Implementing <i>ab + cd</i> as <i>a + b + cd</i></tr>

</table>
</ol>

<p>
A test set that
detects all LIFs (LIF faults), LRFs, and LOFs is guaranteed to detect
the other six faults.
The Minimal-MUMCUT criterion guarantees detection of all LIFs, LRFs, and LOFs
by selecting specific Unique True Points (UTP) and
Near False Points (NFP) according to complex rules
(as defined in <a href="#PAPERS">the papers</a> referenced below.)
A UTP for a term is a point that makes only that term true.
For <i>ab + cd</i>, <b>1100</b> is a UTP for <b>ab</b>.
An NFP for a literal is a point that makes the predicate false but
if that single literal is negated, the predicate is true.
For <i>ab + cd</i>, an NFP for <i>a</i> is <b>0100</b>.
For readers familiar with the MUMCUT strategy,
Minimal-MUMCUT uses the feasiblity of the MUTP and CUTPNFP criteria to
reduce MUMCUT test set size without sacrificing fault detection.

</p>

<p>
Minimal-MUMCUT is composed of three component criteria: 
</p>
<ol>
  <li><i>MUTP</i> - Guarantees detection of faults ENF, ORF+, LNF, TNF, TOF, LIF, and when feasible, LRF.
  <li><i>CUTPNFP</i> - When feasible, guarantees detection of all faults MUTP detects except LIF.
  <li><i>MNFP</i> - Guarantees detection of faults ENF, TNF, ORF. LNF, LOF, and when feasible, LRF.
</ol>

<p>
There is some debate as to which tests to generate when CUTPNFP is infeasible,
because no UTP-NFP pair exists for some literals in a term.
The approach taken by this tool is that when a corresponding pair does not exist,
a non-corresponding NFP will be selected rather than not
selecting any NFPs at all.
</p>

<p>
When selecting a criterion, the tool shows the truth assignments needed to
satisfy the criterion and also shows a set of mutations whose
corresponding mutants can only be killed by tests that satisfy the criterion.
The tests and mutants are listed in order such that
the first test can kill the first mutant,
the second test can kill the second mutant,
and so on.
</p>

<p>
The mutants generated by the tool correspond to one of seven fault types:
</p>
 <ol>
   <li>(false)
   <li>(true)
   <li>TOF
   <li>LIF-LIF
   <li>Term Replacement Fault - Literal Insertion Faults (TRF-LIF)
   <li>Term Insertion Fault   - Literal Reference Faults (TIF-LRF)
   <li>Term Insertion Fault   - Literal Omission  Fault  (TIF-LOF)
 </ol>

<p>
A (<i>false</i>) mutant means that the predicate has been replaced by the keyword false.
A (<i>true</i>) mutant means that the predicate has been replaced by the keyword true.
A <i>TOF</i> is as described above and can be produced when a term in the predicate contains all unique literals.
A <i>LIF-LIF</i> is a double fault where a LIF occurs in two different terms and is only generated as a mutant
when selecting the Minimal-MUMCUT/SMOTP option.
</p>

<p>
A <i>TRF-LIF</i> involves replacing a term by one or more terms so that
if the fault is detected,
the tests are guaranteed to detect one or more LIFs.
For <i>ab + cd</i>, a TRF-LIF would be <i>abc + ab!d + cd</i>.

</p>

<p>
A TIF-LRF involves inserting a term such that if the fault is detected,
the test is guaranteed to detect one or more LRFs.
For <i>ab + bc</i>, a TIF-LRF would be <i>ab + bc + a!b!c</i>.
</p>

<p>
A TIF-LOF involves inserting a term such that if the fault is detected,
the test is guaranteed to detect one or more LOFs.
For <i>ab + cd</i>, a TIF-LOF would be <i>ab + cd + a!bc!d</i>.
</p>

<p>
The tool abbreviates each TRF-LIF as a TRF and collectively abbreviates TIF-LRFs and TIF-LOFs as TIFS.
A TRF mutant can only be killed by an UTP and a TIF mutant can only be killed by a NFP.
</p>

<p>
The tool also detects equivalent LIF and LRF mutants so that all
mutants generated are non-equivalent.
For example, given <i>ab + bc</i>, an equivalent LIF would be <i>ab!c + bc</i>.
</p>

<p>
The test data generated for Minimal-MUMCUT will also
detect most double faults (killing second order mutants).
Of the 81 (9x9) double fault types,
all but six are guaranteed to be detected by a
test set that satisfies the Minimal-MUMCUT criterion.
The six double fault types that are not guaranteed to be detected are
TOF-LRF, ORF.-LRF, LOF-LRF, LIF-LRF, LRF-LRF, and LIF-LIF.
</p>

<p>
In practice it has been found to be likely that a
Minimal-MUMCUT test set will detect all but the LIF-LIF faults.
Incorporating a criterion known as SMOTP for pairs of MUTP infeasible terms will
guarantee detection of all occurrences of double LIFs.
To guarantee this, when selecting Minimal-MUMCUT/SMOTP,
Overlapping True Points (OTPs) may be included in the tests.
An OTP is a point that makes two terms true in the predicate.
For <i>a!bc + a!dc + e</i>, an OTP for the first two terms is <b>10100</b>.
This is the only point that can detect the double LIF:
<i>a!bcd + a!dcb + e</i>.
TRF mutants,
where a TRF occurs in two terms,
are generated and such mutants can only be killed by an OTP that detects the LIF-LIF.
</p>

<p>
For users who are familiar with the MUTP strategy,
a Minimal-MUMCUT test set guarantees detection of all double faults
if and only if MUTP is feasible.
For users familiar with the CUTPNFP strategy,
a Minimal-MUMCUT test set guarantees detection of all but the LIF-LIF
if and only if CUTPNFP is feasible.
Thus, the data generated from the Minimal-MUMCUT/SMOTP option
is guranteed to detect all but five double fault types,
but when the CUTPNFP stragegy is feasible,
the data generated from the tool will detect all double fault types.
In practice it has been found that the CUTPNFP strategy is usually feasible.
</p>

<p>
<b>Restrictions</b>:

</p>
<ul>
 <li>Predicates are limited to 26 unique literals
 <li>Predicates must be in Minimal DNF. 
 <li>Each literal must be a single lower case letter.
 <li>No letters of the alphabet may be skipped.
    For example, <i>a</i> &amp; <i>b</i> is valid but <i>a</i> &amp; <i>c</i>

    is not since the letter <i>b</i> is skipped.
 <li>The infeasible literal combinations must
      allow at least a single UTP for each term and a single NFP for each literal.
</ul>

<p>
The various minimization options produce a combinatorial
optimization model to minimize the number of tests needed to satisfy
(as much as possible) the chosen criterion.
While a MUTP, CUTPNFP, or MNFP test set
produced by the tool is guaranteed to be minimal in the
sense that if even one test is removed,
the criterion will not be satisfied,
it is not necessarily <b>minimum</b> in that it may be possible
to form a test set with fewer tests and still satisfy the criterion.
The optimization problem can be run in an LP solver such as MPL or
CPLEX to obtain a minimum test set.
To run the model in a solver you may need to remove the ";" characters in the model
(some solvers require a ";" to separate constraints whereas for others using it
causes a warning that can lead to incorrect results).
</p>

<p>
The Fault Detection Maximization option takes as input the desired
test set size and produces a combinatorial optimization model to solve
the problem of finding a test set of that size that maximizes the
number of minimal DNF single logic faults detected.

</p>

<a name="PAPERS"></a>
<p>
Technical details on these criteria are in the the following papers:
</p>
<ul>
   <li><i>Reconciling perspectives of software logic testing</i>,
      Garrett Kaminski, Gregory Williams, and Paul Ammann,
      Software Testing, Verification, and Reliability, 18(3):149-188, September 2008. 
   <li><i>Using a Fault Hierarchy to Improve the Efficiency of DNF Logic Mutation Testing</i>,
      Garrett Kaminski and Paul Ammann,
      2nd IEEE International Conference on Software Testing, Verification and Validation (ICST 2009), pages 386-395,
      Denver CO, April 2009, IEEE Computer Society
  <li><i>Using Logic Criterion Feasibility to Reduce Test Set Size While Guaranteeing Fault Detection</i>,
      Garrett Kaminski and Paul Ammann,
      2nd IEEE International Conference on Software Testing, Verification and Validation (ICST 2009), 356-365,
      Denver CO, April 2009, IEEE Computer Society
  <li><i>Using Logic Criterion Feasibility to Reduce Test Set Size While Guaranteeing Double Fault Detection</i>,
      Garrett Kaminski and Paul Ammann,
      Mutation 2009 Workshop, pages 167-176,
      Denver CO, April 2009, IEEE Computer Society
</ul>

<p>
In the fault detection maximization model, faults involving a term
are modeled as variables whose names consist of the fault type,
followed by an underscore, followed by the term the fault occurs in.
For example, a TOF for the 2nd term would correspond to the variable
TOF_2 in the optimization model.
Faults involving a literal are modeled as variables whose names consist of the fault type,
followed by an underscore,
followed by the term the fault occurs in,
followed by an underscore,
followed by the literal in the term the fault occurs in.
For example, a LOF for the 3rd literal in the 2nd term would be
represented by the variable LOF_2_3 in the optimization model.
For LIFs and LRFs, the corresponding variable names in the optimization model
include an additional underscore indicating the name of the literal
that is being inserted or referenced, where uppercase indicates negation.
For example, LRF_3_2_C corresponds to a fault where the 2nd
literal in the 3rd term is repl aced with the literal <i>!c</i>.
For users familiar with optimization modeling,
the variables that begin with a captial "<i>M</i>" are used for constratins that model implications.
These constratints ensure that a given fault is detected if and only if
one of the test points that detects the fault is chosen.
</p>

<p style="font-size: 80%; font-family: monospace;">
Companion software
<br/>to <i>Introduction to Software Testing</i>, Ammann and Offutt.
<br/>Implementation by Gary Kaminski and Nan Li.
<br/>&#169; 2007-2010, all rights reserved.

<br/>Last update: 8-February-2010
</p>

</body>
</html>
